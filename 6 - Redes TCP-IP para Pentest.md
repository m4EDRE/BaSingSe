
A sessão a seguir tem como finalidade explorar as principais questão de redes que um Pentester deve dominar no dia a dia.

# Introdução a redes e Protocolos

Essa sessão é referente a base sobre o conhecimento de Redes para Pentesters, de forma que essa base servirá depois para podermos realizar os laboratórios e prosseguirmos nos estudos da área.

Socket = IP + Porta

Comando no Linux que mostra cálculos de máscara de IPs

`ip calc <IP> <Mask in 255 notation>`

### Protocolos Ethernet, ARP e TCP

- Protocolo Ethernet:
    
    - Protocolo em layer 2 (endereços físicos)
    - Tipos: ARP e IP
    - Estrutura: Tipo, Source e Destino
- Protocolo ARP:
    
    - IP x MAC Address
    - `arp -a` —> Mostra tabela ARP do Linux
    - Estrutura: Source MAC e IP, Destination MAC e IP
    - Código 1 = Request
    - Código 2 = Reply
    - MAC é so de parceiro a parceiro, não resiste ao hop
- Protocolo IP
    
    - Versão: 4 ou 6
    - TTL
    - Protocolo: Seja ele qual for
    - Source e destination


# Fragmentando IPs, TCP, UDP e DNS

Fragmentação do pacote IP

Quando o pacote IP tem mais +1500 bits ele deve ser fragmentado em outro pacote para que seja possível o transporte. Para isso existem as sessões no Header —> Flags e Identifications

- **Identification**: Item no header que é sempre o mesmo para todos os pacotes que foram fragmentados, ele ajuda a mostrar quais pacotes fazem parte da mesma unidade mas foram separados
- **Flags**: Dentro das flags desse cabeçalho temos um item importatissimo que informa se existem outros pacotes a chegarem pela fragmentação ou se aquele pacote já foi todo fragmentado e esse é o ultimo deles
    - Fragment Offset —> Incrementado conforme vem mais pacotes, mostra a ordem
    - Se tudo estiver em Not Set é pq esse é o ultimo pacote

**Protocolo TCP**

- 3 Way Hand Shake: Protocolo orientado a conexão
    - Tem acknolegement packet que garante a entrega dessa comunicação.
    - SYN/SYNACK/ACK
    - Flags dentro do cabeçalho sem set demonstram o que é o pacote
- **SYN** e **ACK** são Flags do cabeçalho
- Finalizando comunicação: envia Flag **FIN**
- Erro de comunicação: Envia Flag **RST**
- Priorização da mensagem: Flag **URG**

**Protocolo UDP**

- Muito mais rápido que TCP
- Não orientado a conexão
- Header com apenas source e destination

# DNS, HTTP e ICMP

**DNS**

- Domain Name Server
- Requisições de endereços são querrys

**HTTP**

- Web Browser x Web Server
- GET,POST,PUT,DELETE,OPTIONS,HEAD,PATCH
- Request e Response
- 200,301,403,404 e 500 code
- Head e Body

**ICMP**

- Type e Code dentro do cabeçalho
- 8 e 0 (Request e Reply)
- TTL diminui conforme os saltos na topologia

# Bytes na Rede

Aqui exploraremos mais a fundo os cabeçalhos estudados acima olhando os bits. Isso é muito útil pois é um conhecimento aprofundado

## Bytes na Layer 2
![[Pasted image 20251109193548.png]]

Os primeiros 14 bytes são os destinados a L2

6 bytes Vermelhos —> MAC Destino

6 bytes Verdes —> MAC Origem

2 bytes roxos —> Tipo (ARP x IP)

## Bytes na Layer 3 (IP)
![[Pasted image 20251109193707.png]]

Logo após os bytes destinados a L2 teremos os bytes de L3

Para sabermos quantos serão basta fazer 4 bytes x o campo IHL (Destinado para o calculo de bytes)

1/2 Byte —> Tipo (4 ou 6)

1/2 Byte —> IHL

1 Byte —> ToS

O restante serve para Source e Destination, TTL e Protocol

## Bytes na Layer 4 (TCP x UDP)
![[Pasted image 20251109193742.png]]

4 Bytes —> Source e Destination Port

4 Bytes —> Data Offset: Quantos bytes para acabar o header

4 Bytes —> Sequence Number

4 bytes —> Ack Number

1 Byte —> Flag number

## Bytes na Rede - Payload

Os Bytes a seguir serão os destinados a payload

É muito importante entender que esses bytes contém a **MENSAGEM** enviada pelo usuário e essa mensagem pode ser decodificada usando a tabela **ASCII.**

Para isso usaremos o seguinte comando:

`mas ascii`

`printf “\\x<Byte>\\x45\\etc etc\\n”`

Com isso é possível ver a mensagem dentro via bytes capturados